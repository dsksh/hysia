#let   intv = [-1e-1,1e-1]
#let   intv = [-1e-2,1e-2]
#let   intv = [-1e-3,1e-3]
#let   intv = [-1e-8,1e-8]
let   intv = 0

let   c0 = 0.1
#let   c1 = 0.1
#let   c1 = [-1e-5,1e-5]
let   c1 = R 0.2
#let   c1 = 0.15
#let   c1 = -0.05
let   c2 = -1
let   c3 = 1
#let   c4 = -1
#let   c4 = 0
#let   c4 = R 0.1

var   x1, x2

#init  Loc, 1+intv, intv
#init  Loc, 0.8661, 0.5
init  Loc, 1, 0

#at Loc wait (c1-c0)*x1 + c2*x2, c3*x1 + (c1-c0)*x2
at Loc wait (c1-c0+intv)*x1 + c2*x2, c3*x1 + (c1-c0+intv)*x2
end

prop G[0,100] F[0,6.284]!(1-x2) (* 1<=x2 *)
#prop G[0,100] F[0,6.284](!(1-x2) & F[0,3.1416]!(x2+1))
#prop G[0,100] F[0,6.284](!(1-x2) & F[0,1.571]((!x2) & F[0,1.571](!(x2+1) & F[0,1.571](x2) )))
#prop G[0,20]
#  F[0,6.284](!(1-x2) & F[0,0.786]((-x2+0.7071) & F[0,0.786](!(x2) & F[0,0.786](!(x2+0.7071) & 
#  F[0,0.786](!(x2+1) & F[0,0.786]( (x2+0.7071) & F[0,0.786]( (x2) & F[0,0.786]  (x2+0.7071) )))))))

# prop G[0,20] F[0,6.284](
#   (1-x2) U[0,0.786] ( (0.7071-x2) U[0,1.571] (!(x2+0.7071) U[0,0.786] 
# (!(x2+1) U[0,0.786] (!(x2+0.7071) U[0,1.571] ( (0.7071-x2) U[0,0.786] (1-x2)) )))))

#prop G[0,100] F[0,6.284](x2) (* x2>0 *)

# these are not verified successfully
#prop G[0,10] (F[0,3.1415](x2) & F[0,3.1415](!x2)) (* c1 = 0.1000001 *)
#prop G[0,20] F[0,6.284] 
#  ((-x2+0.7071) U[0,1.571] ((!(x2+0.7071)) U[0,1.571] ((x2+0.7071) U[0,1.771] (!(-x2+0.7071)) )))
#prop G[0,20] (F[0,6.284]( !(-x2+0.7071) U[0,0.786] ((-x2+0.7071) U[0,1.571] !(x2+0.7071) U[0,0.786] (!(x2+1) & (!(x2+0.7071) U[0,0.786] ((x2+0.7071) U[0,1.571] (!(-x2+0.7071) U[0,0.786] !(1-x2))))))))

param order = 10
param t_max = 100
param h_min   = 1e-14
param epsilon = 1e-14
#param epsilon = 0
#param dump_interval = 0.1
param dump_interval = 0.9
param char_mtx = -1
#param char_mtx = 3
